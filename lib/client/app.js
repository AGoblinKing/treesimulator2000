// Generated by CoffeeScript 1.4.0
(function() {
  var Controls, Land;

  Land = require("./entities/land");

  Controls = (function() {

    function Controls(camera, speed, grid) {
      var _this = this;
      this.camera = camera;
      this.speed = speed != null ? speed : 10;
      this.grid = grid != null ? grid : [];
      this.keyState = new THREEx.KeyboardState();
      this.mouse = new THREE.Vector2();
      this.projector = new THREE.Projector();
      this.curUpdate = 0;
      this.selected = void 0;
      this.lastPos = this.camera.position;
      $("body").mousemove(function(e) {
        var intersects, ray, vector;
        _this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        _this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        vector = new THREE.Vector3(_this.mouse.x, _this.mouse.y, 0.5);
        _this.projector.unprojectVector(vector, _this.camera);
        ray = new THREE.Ray(_this.camera.position, vector.subSelf(_this.camera.position).normalize());
        intersects = ray.intersectObjects(_this.grid);
        if (intersects.length > 0) {
          if (_this.selected !== intersects[0].object) {
            return _this.changeSelected(intersects[0].object);
          }
        }
      });
      $("body").mousewheel(function(e, delta, deltaX, deltaY) {
        var newLook;
        _this.camera.position.z += deltaY * 2;
        newLook = _this.camera.position.copy();
        newLook.y += 5;
        newLook.z -= 20;
        return _this.camera.lookAt(newLook);
      });
    }

    Controls.prototype.changeSelected = function(newSelected) {
      if (this.selected) {
        this.selected.material.color = this.selectedoldColor;
      }
      this.selected = newSelected;
      this.selectedoldColor = this.selected.material.color;
      return this.selected.material.color = new THREE.Color(0xFF0000);
    };

    Controls.prototype.updateRate = 100;

    Controls.prototype.moveUpdate = function(delta) {
      var pos, _ref;
      this.curUpdate += delta * 1000;
      if (this.curUpdate >= this.updateRate) {
        this.curUpdate = 0;
        pos = {
          x: this.camera.position.x,
          y: this.camera.position.y + 5,
          z: 0
        };
        return (_ref = this.socket) != null ? _ref.emit("update", pos) : void 0;
      }
    };

    Controls.prototype.update = function(delta) {
      this.moveUpdate(delta);
      if (this.keyState.pressed("w")) {
        this.camera.position.y += this.speed * delta;
      }
      if (this.keyState.pressed("s")) {
        this.camera.position.y -= this.speed * delta;
      }
      if (this.keyState.pressed("a")) {
        this.camera.position.x -= this.speed * delta;
      }
      if (this.keyState.pressed("d")) {
        return this.camera.position.x += this.speed * delta;
      }
    };

    return Controls;

  })();

  $(function() {
    var ASPECT, FAR, HEIGHT, NEAR, VIEW_ANGLE, WIDTH, camera, clock, controls, entities, fogged, light, render, renderer, scene, socket;
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    VIEW_ANGLE = 45;
    ASPECT = WIDTH / HEIGHT;
    NEAR = 0.1;
    FAR = 100000;
    renderer = new THREE.WebGLRenderer();
    renderer.shadowMapEnabled = true;
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    camera.position.set(0, -5, 20);
    camera.lookAt(scene.position);
    scene.add(camera);
    light = new THREE.PointLight(0xFFFFFF);
    light.position.set(0, 0, 0);
    camera.add(light);
    controls = new Controls(camera, 10, scene.children);
    render = function() {
      controls.update(clock.getDelta());
      renderer.render(scene, camera);
      return requestAnimationFrame(render);
    };
    socket = io.connect(null, {
      reconnect: false
    });
    controls.socket = socket;
    entities = {};
    fogged = [];
    socket.on("update", function(view) {
      var entity, id, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = view.length; _i < _len; _i++) {
        entity = view[_i];
        switch (entity.type) {
          case "fog":
            if (entities[entity.properties.id]) {
              entities[entity.properties.id].kill();
              entities[entity.properties.id] = void 0;
              _results.push(delete entities[entity.properties.id]);
            } else {
              _results.push(void 0);
            }
            break;
          default:
            id = entity.properties.id;
            if (!entities[id]) {
              _results.push(entities[id] = new Land(entity, scene));
            } else {
              _results.push(entities[id].update(entity));
            }
        }
      }
      return _results;
    });
    return render();
  });

}).call(this);
