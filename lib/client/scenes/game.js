// Generated by CoffeeScript 1.4.0
(function() {

  define(["../entities/land", "threejs", "jquery", "jquery-mousewheel"], function(Land, THREE, $) {
    var Controls, KeyState;
    KeyState = (function() {

      function KeyState(dom) {
        var _this = this;
        this.keys = {};
        $(dom).on("keydown", function(e) {
          _this.keys[e.keyCode] = true;
          return _this.keys[String.fromCharCode(e.keyCode)] = true;
        });
        $(dom).on("keydown", function(e) {
          delete _this.keys[e.keyCode];
          return delete _this.keys[String.fromCharCode(e.keyCode)];
        });
      }

      KeyState.prototype.pressed = function(key) {
        return this.keys[key];
      };

      return KeyState;

    })();
    Controls = (function() {

      function Controls(camera, speed, grid) {
        var _this = this;
        this.camera = camera;
        this.speed = speed != null ? speed : 10;
        this.grid = grid != null ? grid : [];
        this.keyState = new KeyState("body");
        this.mouse = new THREE.Vector2();
        this.projector = new THREE.Projector();
        this.curUpdate = 0;
        this.selected = void 0;
        this.lastPos = this.camera.position;
        /*
                    $("body").mousemove (e) =>
                        @mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                        @mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
                        vector = new THREE.Vector3 @mouse.x, @mouse.y, 0.5 
                        @projector.unprojectVector vector, @camera 
        
                        ray = new THREE.Ray @camera.position, vector.subSelf(@camera.position).normalize() 
        
                        intersects = ray.intersectObjects @grid
                        if intersects.length > 0 
                            if @selected != intersects[0].object
                                @changeSelected intersects[0].object
        */

        $("body").mousewheel(function(e, delta, deltaX, deltaY) {
          var newLook;
          _this.camera.position.z += deltaY * 2;
          newLook = _this.camera.position.copy();
          newLook.y += 5;
          newLook.z -= 20;
          return _this.camera.lookAt(newLook);
        });
      }

      Controls.prototype.changeSelected = function(newSelected) {
        if (this.selected) {
          this.selected.material.color = this.selectedoldColor;
        }
        this.selected = newSelected;
        this.selectedoldColor = this.selected.material.color;
        return this.selected.material.color = new THREE.Color(0xFF0000);
      };

      Controls.prototype.updateRate = 100;

      Controls.prototype.moveUpdate = function(delta) {
        var pos, _ref;
        this.curUpdate += delta * 1000;
        if (this.curUpdate >= this.updateRate) {
          this.curUpdate = 0;
          pos = {
            x: this.camera.position.x,
            y: this.camera.position.y + 5,
            z: 0
          };
          return (_ref = this.socket) != null ? _ref.emit("update", pos) : void 0;
        }
      };

      Controls.prototype.update = function(delta) {
        this.moveUpdate(delta);
        if (this.keyState.pressed("W")) {
          this.camera.position.y += this.speed * delta;
        }
        if (this.keyState.pressed("S")) {
          this.camera.position.y -= this.speed * delta;
        }
        if (this.keyState.pressed("A")) {
          this.camera.position.x -= this.speed * delta;
        }
        if (this.keyState.pressed("D")) {
          return this.camera.position.x += this.speed * delta;
        }
      };

      return Controls;

    })();
    console.log("ran");
    return $(function() {
      var ASPECT, FAR, HEIGHT, NEAR, VIEW_ANGLE, WIDTH, camera, clock, controls, entities, fogged, light, render, renderer, scene, socket;
      WIDTH = window.innerWidth;
      HEIGHT = window.innerHeight;
      VIEW_ANGLE = 45;
      ASPECT = WIDTH / HEIGHT;
      NEAR = 0.1;
      FAR = 100000;
      renderer = new THREE.WebGLRenderer();
      renderer.shadowMapEnabled = true;
      renderer.setSize(WIDTH, HEIGHT);
      document.body.appendChild(renderer.domElement);
      clock = new THREE.Clock();
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
      camera.position.set(0, -5, 20);
      camera.lookAt(scene.position);
      scene.add(camera);
      light = new THREE.PointLight(0xFFFFFF);
      light.position.set(0, 0, 0);
      camera.add(light);
      controls = new Controls(camera, 10, scene.children);
      render = function() {
        controls.update(clock.getDelta());
        renderer.render(scene, camera);
        return requestAnimationFrame(render);
      };
      socket = io.connect(null, {
        reconnect: false
      });
      controls.socket = socket;
      entities = {};
      fogged = [];
      socket.on("update", function(view) {
        var entity, id, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = view.length; _i < _len; _i++) {
          entity = view[_i];
          switch (entity.type) {
            case "fog":
              if (entities[entity.properties.id]) {
                entities[entity.properties.id].kill();
                entities[entity.properties.id] = void 0;
                _results.push(delete entities[entity.properties.id]);
              } else {
                _results.push(void 0);
              }
              break;
            default:
              id = entity.properties.id;
              if (!entities[id]) {
                _results.push(entities[id] = new Land(entity, scene));
              } else {
                _results.push(entities[id].update(entity));
              }
          }
        }
        return _results;
      });
      return render();
    });
  });

}).call(this);
