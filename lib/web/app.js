// Generated by CoffeeScript 1.3.3
(function() {
  var Controls, Land;

  Controls = (function() {

    function Controls(camera, speed, grid) {
      var _this = this;
      this.camera = camera;
      this.speed = speed != null ? speed : 10;
      this.grid = grid != null ? grid : [];
      this.keyState = new THREEx.KeyboardState();
      this.mouse = new THREE.Vector2();
      this.projector = new THREE.Projector();
      this.selected = void 0;
      $("body").mousemove(function(e) {
        var intersects, ray, vector;
        _this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        _this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        vector = new THREE.Vector3(_this.mouse.x, _this.mouse.y, 0.5);
        _this.projector.unprojectVector(vector, _this.camera);
        ray = new THREE.Ray(_this.camera.position, vector.subSelf(_this.camera.position).normalize());
        intersects = ray.intersectObjects(_this.grid);
        if (intersects.length > 0) {
          if (_this.selected !== intersects[0].object) {
            return _this.changeSelected(intersects[0].object);
          }
        }
      });
      $("body").mousewheel(function(e, delta, deltaX, deltaY) {
        var newLook;
        _this.camera.position.z += deltaY * 2;
        newLook = _this.camera.position.copy();
        newLook.y += 5;
        newLook.z -= 20;
        return _this.camera.lookAt(newLook);
      });
    }

    Controls.prototype.changeSelected = function(newSelected) {
      if (this.selected) {
        this.selected.material.color = this.selectedoldColor;
      }
      this.selected = newSelected;
      this.selectedoldColor = this.selected.material.color;
      return this.selected.material.color = new THREE.Color(0xFF0000);
    };

    Controls.prototype.update = function(delta) {
      if (this.keyState.pressed("w")) {
        this.camera.position.y += this.speed * delta;
      }
      if (this.keyState.pressed("s")) {
        this.camera.position.y -= this.speed * delta;
      }
      if (this.keyState.pressed("a")) {
        this.camera.position.x -= this.speed * delta;
      }
      if (this.keyState.pressed("d")) {
        return this.camera.position.x += this.speed * delta;
      }
    };

    return Controls;

  })();

  Land = (function() {

    function Land(entity, scene) {
      var geom, mat, obj, props;
      this.properties = entity.properties;
      geom = new THREE.PlaneGeometry(1, 1);
      mat = new THREE.MeshLambertMaterial({
        color: this.computeColor()
      });
      obj = new THREE.Mesh(geom, mat);
      props = entity.properties;
      obj.position.x = props.x;
      obj.position.y = props.y;
      obj.position.z = props.z;
      /*
              outline = new THREE.MeshLambertMaterial
                  color: 0x000000
                  wireframe: true
              outlineMesh = new THREE.Mesh geom, outline
              outlineMesh.position.z += .001
              obj.add outlineMesh
      */

      scene.add(obj);
    }

    Land.prototype.computeColor = function() {
      var color, green;
      color = new THREE.Color(0x5E2605);
      green = this.properties.nitrogen / 100 * 1;
      green += this.properties.potassium / 100 * 1;
      green += this.properties.phosphorus / 100 * 1;
      color.g = green / 3;
      return color;
    };

    return Land;

  })();

  $(function() {
    var ASPECT, FAR, HEIGHT, NEAR, VIEW_ANGLE, WIDTH, camera, clock, controls, light, render, renderer, scene, socket;
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    VIEW_ANGLE = 45;
    ASPECT = WIDTH / HEIGHT;
    NEAR = 0.1;
    FAR = 100000;
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    camera.position.set(0, -5, 20);
    camera.lookAt(scene.position);
    scene.add(camera);
    light = new THREE.PointLight(0xFFFFFF);
    light.position.set(0, 0, 0);
    camera.add(light);
    controls = new Controls(camera, 10, scene.children);
    render = function() {
      controls.update(clock.getDelta());
      renderer.render(scene, camera);
      return requestAnimationFrame(render);
    };
    socket = io.connect();
    socket.on("view", function(world) {
      var entity, _i, _len, _ref, _results;
      _ref = world.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        _results.push(new Land(entity, scene));
      }
      return _results;
    });
    return render();
  });

}).call(this);
