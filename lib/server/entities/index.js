// Generated by CoffeeScript 1.4.0
(function() {
  var CSON, Entities, Entity, addEntity, dir, file, fs, logger, path,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require("fs");

  file = require("file");

  CSON = require("cson");

  path = require("path");

  logger = require("../logger");

  Entity = require("../classes/entity");

  dir = process.cwd().split(path.sep);

  if (dir[dir.length - 1] === "lib") {
    dir.splice(-1, 1);
  }

  Entities = {};

  addEntity = function(name, data) {
    var DataEntity;
    if (data.message) {
      logger.error("Unable to parse data file " + name + ": " + data.message);
      return;
    }
    return Entities[name] = Entities[name.charAt(0).toUpperCase() + name.slice(1)] = DataEntity = (function(_super) {

      __extends(DataEntity, _super);

      function DataEntity() {
        return DataEntity.__super__.constructor.apply(this, arguments);
      }

      DataEntity.prototype.parseProperties = function(dataProperties) {
        var properties, property, value;
        properties = {};
        for (property in dataProperties) {
          value = dataProperties[property];
          if (typeof value === "object") {
            switch (value.type) {
              case "range":
                if ((value.min != null) && (value.max != null)) {
                  value = value.min + Math.random() * (value.max - value.min);
                } else {
                  logger.error("Invalid range attribute found in data entry: " + name + ":" + property);
                  value = 0;
                }
            }
          }
          properties[property] = value;
        }
        return properties;
      };

      DataEntity.prototype.init = function() {
        if (!(data.propeties != null)) {
          data.propreties = {};
        }
        if (!(data.privates != null)) {
          data.privates = {};
        }
        return this.load({
          properties: this.parseProperties(data.properties),
          privates: this.parseProperties(data.privates),
          conditionals: data.conditionals,
          goals: data.goals,
          view: data.view,
          debug: data.debug
        });
      };

      return DataEntity;

    })(Entity);
  };

  file.walkSync("" + (dir.join(path.sep)) + "\\data\\entities", function(dir, dirs, files) {
    var contents, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      contents = fs.readFileSync("" + dir + "/" + file, "utf8");
      _results.push(addEntity(path.basename(file, ".cson"), CSON.parseSync(contents)));
    }
    return _results;
  });

  module.exports = Entities;

}).call(this);
